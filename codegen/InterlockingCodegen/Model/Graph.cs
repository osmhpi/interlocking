using Antlr4.Runtime;
using Newtonsoft.Json;
using static GraphParser;

namespace FormalInterlocking.Model;

public record Subgraph(
  List<TransitionInfo> Transitions,
  Dictionary<string, List<AssignmentContext>> StateAssignments,
  List<string> ChoicePseudostates,
  Dictionary<string, Subgraph> NestedSubgraphs
)
{
  public static Subgraph Parse(DiagramBodyContext diagramBody)
  {
    // Parse the pseudostate definitions
    var pseudostates = new List<string>();
    foreach (var pseudo in diagramBody.pseudostateDeclaration())
    {
      var name = pseudo.pseudostateName()?.GetText();
      var type = pseudo.PSEUDOSTATE()?.GetText();
      if (!string.IsNullOrEmpty(name) && !string.IsNullOrEmpty(type))
      {
        pseudostates.Add($"{name}:{type}");
      }
    }

    // Parse the transition priorities and conditions
    var transitions = new List<TransitionInfo>();
    foreach (var transition in diagramBody.transition())
    {
      var from = transition.stateReference(0)?.GetText();
      var to = transition.stateReference(1)?.GetText();

      int? priority = null;
      if (transition.transitionLabel().priority() != null)
      {
        if (int.TryParse(transition.transitionLabel().priority().INT()?.GetText(), out var p))
          priority = p;
      }

      string? condition = null;
      ExpressionContext? parsedCondition = null;
      if (transition.transitionLabel() != null)
      {
        parsedCondition = transition.transitionLabel().labelText().expression();
      }

      if (!string.IsNullOrEmpty(from) && !string.IsNullOrEmpty(to))
      {
        transitions.Add(new TransitionInfo(from, to, priority, condition, parsedCondition));
      }
    }

    // Parse the assignments that are given for each state
    // These are not part of the transitions, but rather part of the state definitions
    var stateAssignments = new Dictionary<string, List<AssignmentContext>>();
    var subgraphs = new Dictionary<string, Subgraph>();

    // Parse repeated state assignments (e.g., OCCUPIED: State = ...)
    foreach (var stateAssignment in diagramBody.stateDeclaration())
    {
      var stateName = stateAssignment.stateReference()?.GetText();
      var assignment = stateAssignment.assignment();
      if (!string.IsNullOrEmpty(stateName) && assignment != null)
      {
        if (!stateAssignments.ContainsKey(stateName))
          stateAssignments[stateName] = new List<AssignmentContext>();
        stateAssignments[stateName].Add(assignment);
      }
      else if (!string.IsNullOrEmpty(stateName) &&stateAssignment.diagramBody() != null)
      {
        var nestedSubgraph = Parse(stateAssignment.diagramBody());
        subgraphs[stateName] = nestedSubgraph;
      }
    }

    return new Subgraph(transitions, stateAssignments, pseudostates, subgraphs);
  }
}

public record TransitionInfo(
  string From,
  string To,
  int? Priority,
  string? Condition,
  ExpressionContext? ParsedCondition
);

public record Graph(
  string Name,
  DiagramContext ParseTree,
  GraphTerms Terms,
  Subgraph Subgraph
  )
{
  public static Graph Parse(string filePath)
  {
    if (!File.Exists(filePath))
    {
      throw new FileNotFoundException($"The specified file does not exist: {filePath}");
    }

    var input = File.ReadAllText(filePath);
    var inputStream = new AntlrInputStream(input);
    var lexer = new GraphLexer(inputStream);
    var tokenStream = new CommonTokenStream(lexer);
    var parser = new GraphParser(tokenStream);

    var hasParseErrors = false;
    parser.RemoveErrorListeners();
    parser.AddErrorListener(new ErrorListener((line, charPositionInLine, msg) =>
    {
        Console.Error.WriteLine($"Parse error at line {line}, char {charPositionInLine}: {msg}");
        hasParseErrors = true;
    }));

    // Use the correct entry point as generated by ANTLR (diagram)
    var tree = parser.diagram();

    if (hasParseErrors)
    {
        throw new InvalidOperationException($"Failed to parse the graph file: {filePath}");
    }

    // Get the diagram name
    var diagramName = tree.diagramName()?.graphOrInterfaceName()?.GetText();
    if (string.IsNullOrEmpty(diagramName))
    {
      throw new InvalidOperationException("The diagram name could not be determined from the parse tree.");
    }

    var subgraph = Subgraph.Parse(tree.diagramBody());

    // Parse terms yaml file, has .terms.yaml extension instead of .puml
    GraphTerms terms;
    var termsFilePath = Path.ChangeExtension(filePath, ".terms.yaml");
    if (!File.Exists(termsFilePath))
    {
      throw new FileNotFoundException($"The terms file does not exist: {termsFilePath}");
    }

    try
    {
      var termsContent = File.ReadAllText(termsFilePath);
      var jsonContent = Specification.YamlToJson(termsContent);
      terms = JsonConvert.DeserializeObject<GraphTerms>(jsonContent) ?? throw new InvalidOperationException($"Failed to deserialize terms from {termsFilePath}");
    }
    catch (Exception ex)
    {
      throw new InvalidOperationException($"Failed to read terms file {termsFilePath}: {ex.Message}", ex);
    }

    // Parse the term definitions
    foreach (var term in terms.Terms.Where(x => x.Value.Expression != null))
    {
      var termInput = new AntlrInputStream(term.Value.Expression);
      var termLexer = new ExpressionLexer(termInput);
      var termTokenStream = new CommonTokenStream(termLexer);
      var termParser = new ExpressionParser(termTokenStream);

      termParser.RemoveErrorListeners();
      termParser.AddErrorListener(new ErrorListener((line, charPositionInLine, msg) =>
      {
          Console.Error.WriteLine($"Parse error at line {line}, char {charPositionInLine}: {msg}");
          hasParseErrors = true;
      }));

      var termTree = termParser.expression() ?? throw new InvalidOperationException($"Failed to parse term expression for {term.Key} in {termsFilePath}");

      if (hasParseErrors)
      {
          throw new InvalidOperationException($"Failed to parse term expression for {term.Key} in {termsFilePath}");
      }

      // Check for unconsumed tokens
      if (termParser.CurrentToken.Type != TokenConstants.EOF)
      {
        throw new InvalidOperationException($"Extra input after valid term expression for {term.Key} in {termsFilePath}");
      }

      term.Value.ParsedTree = termTree;
    }

    // Parse the variable definitions
    foreach (var variable in terms.Variables)
    {
      var variableInput = new AntlrInputStream(variable.Value.Default);
      var variableLexer = new ExpressionLexer(variableInput);
      var variableTokenStream = new CommonTokenStream(variableLexer);
      var variableParser = new ExpressionParser(variableTokenStream);

      variableParser.RemoveErrorListeners();
      variableParser.AddErrorListener(new ErrorListener((line, charPositionInLine, msg) =>
      {
          Console.Error.WriteLine($"Parse error at line {line}, char {charPositionInLine}: {msg}");
          hasParseErrors = true;
      }));

      var variableTree = variableParser.valueReference() ?? throw new InvalidOperationException($"Failed to parse variable default value for {variable.Key} in {termsFilePath}");

      if (hasParseErrors)
      {
          throw new InvalidOperationException($"Failed to parse variable default value for {variable.Key} in {termsFilePath}");
      }

      // Check for unconsumed tokens
      if (variableParser.CurrentToken.Type != TokenConstants.EOF)
      {
        throw new InvalidOperationException($"Extra input after valid variable default value for {variable.Key} in {termsFilePath}");
      }

      variable.Value.ParsedDefault = variableTree;
    }

    return new Graph(diagramName, tree, terms, subgraph);
  }
}
